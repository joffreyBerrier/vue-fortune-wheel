<template>
  <div
    @click="spin"
    :style="{ width: `${width}px`, height: `${height}px` }"
    id="chart"
  />
</template>

<script lang="ts">
import * as d3 from "d3";
import { ref, defineComponent } from "vue";

export default defineComponent({
  name: "Wheel",
  data() {
    return {
      animDuration: 5000,
      arrow: null,
      color: {
        count: 3,
        colors: ["#7d7db3", "#ffffff", "#c92729"],
      },
      clicked: false,
      container: null,
      countOfRotation: 6,
      currentData: 0,
      data: [
        {
          value: "Fish and Chips",
          id: 1,
        },
        {
          value: "M in Black Burger",
          id: 2,
        },
        {
          value: "Pack de 3 biÃ¨res",
          id: 3,
        },
        {
          value: "Fish Balls x6",
          id: 4,
        },
        {
          value: "Jus de fruits",
          id: 5,
        },
        {
          value: "Dessert maison",
          id: 6,
        },
      ],
      height: 600 as number,
      picked: 100000 as number,
      pie: null,
      rotation: 0 as number,
      svg: null,
      vis: null,
      width: 600 as number,
    };
  },
  mounted() {
    this.rayon = Math.min(this.width, this.height - 10) / 2;
    // Create Svg
    this.createSvg();
    // Create shadow filter
    this.createDefs();
    // Create Group container
    this.createVis();
    // Declare an arc generator function
    this.createArc();
    // Add the text
    this.addText();
    // Make circle
    this.createMiddleCircle();
    this.createBorderCircle();
    // create arrow
    this.createArrow();
  },
  methods: {
    createSvg() {
      const screenWidth = window.innerWidth;
      const margin = 100
      const width = Math.min(screenWidth, this.width) + margin;
      const height = Math.min(screenWidth, this.width) + margin;

      this.svg = d3
        .select("#chart")
        .append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .data([this.data])
        .append("g")
        .attr("class", "wrapper")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);
    },
    createDefs() {
      const defs = this.svg
        .append("defs")
        .append("filter")
        .attr("id", "shadow")
        .attr("x", "-100%")
        .attr("y", "-100%")
        .attr("width", "550%")
        .attr("height", "550%");

      defs
        .append("feOffset")
        .attr("in", "SourceAlpha")
        .attr("dx", 0)
        .attr("dy", 0)
        .attr("result", "offsetOut");

      defs
        .append("feGaussianBlur")
        .attr("stdDeviation", "9")
        .attr("in", "offsetOut")
        .attr("result", "drop");

      defs
        .append("feColorMatrix")
        .attr("in", "drop")
        .attr("result", "color-out")
        .attr("type", "matrix")
        .attr(
          "values",
          `0 0 0 0   0
          0 0 0 0   0
          0 0 0 0   0
          0 0 0 .3 0
        `
        );

      defs
        .append("feBlend")
        .attr("in", "SourceGraphic")
        .attr("in2", "color-out")
        .attr("mode", "normal");
    },
    createVis() {
      this.container = this.svg.append("g").attr("class", "chartholder");

      // Create a G on container
      this.vis = this.container.append("g");

      this.pie = d3
        .pie()
        .value(() => {
          return 1;
        })
        .padAngle(0.01)
        .sort(null);
    },
    createArc() {
      const arc = d3.arc().outerRadius(this.rayon).innerRadius(0);

      // Create the donut slices and also the invisible arcs for the text
      const that = this;

      this.vis
        .selectAll(".middleArcText")
        .data(this.pie(this.data))
        .enter()
        .append("path")
        .attr("class", "slice")
        .attr("d", arc)
        .attr("stroke", "#000000")
        .attr("stroke-width", "3")
        .attr("fill", (_, i) => {
          return this.color.colors[i % this.color.count];
        })
        .each(function (d, i) {
          const firstArcSection = /(^.+?)L/;

          let newArc = firstArcSection.exec(d3.select(this).attr("d"))[1].replace(/,/g, " ");

          if (d.endAngle > (90 * Math.PI) / 180) {
            const startLoc = /M(.*?)A/
            const middleLoc = /A(.*?)0 0 1/
            const endLoc = /0 0 1 (.*?)$/
            const newStart = endLoc.exec(newArc)[1];
            const newEnd = startLoc.exec(newArc)[1];
            const middleSec = middleLoc.exec(newArc)[1];

            newArc = `M${newStart}A${middleSec}0 0 0${newEnd}`;
          }

          that.vis
            .append("path")
            .attr("class", "hiddenarcs")
            .attr("id", "middleArc" + i)
            .attr("d", newArc)
            .style("fill", "none");
        });
    },
    addText() {
      this.vis
        .selectAll(".middleArcText")
        .data(this.pie(this.data))
        .enter()
        .append("text")
        .attr("class", "middleArcText")
        .attr("dy", (d, i) => {
          return d.endAngle > (90 * Math.PI) / 180 ? -30 : 42;
        })
        .append("textPath")
        .attr("startOffset", "50%")
        .style("text-anchor", "middle")
        .attr("xlink:href", (d, i) => {
          return "#middleArc" + i;
        })
        .text((d) => {
          return d.data.value;
        });
    },
    createArrow() {
      const pathArrow =
        "M95.3,9.8c-16.5,0-23.7,15.6-21.9,27c3.4,21.7,21.9,42.2,21.9,42.2s18.5-20.5,21.9-42.2 C118.9,25.4,111.8,9.8,95.3,9.8z";

      this.arrow = this.container
        .append("g")
        .append("path")
        .attr("d", pathArrow)
        .attr("transform", "translate(-20, -300)")
        .attr("stroke", this.color.arrowBg)
        .attr("fill", "#FFFFFF")
        .attr("filter", "url(#shadow)")
        .attr("transform", "matrix(1, 0, 0, 1, -95, -350)")
        .attr("stroke-linejoin", "round")
        .attr("stroke-width", "4");
    },
    createMiddleCircle() {
      this.container
        .append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", 100)
        .attr("fill", "#ffffff")
        .attr("filter", "url(#shadow)")
        .attr("stroke-width", 6)
        .attr("stroke", "#000000");
    },
    createBorderCircle() {
      this.container
        .append("g")
        .append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", (this.width - 18) / 2)
        .attr("fill", "transparent")
        .attr("stroke-width", "18")
        .attr("filter", "url(#shadow)")
        .attr("stroke", "#ffffff");
    },
    findCurrentSlice(index) {
      return this.data.findIndex((x) => x.id === index) + 1;
    },
    async spin(d) {
      if (!this.clicked) {
        this.clicked = true

        // Define current gain
        this.currentData = this.findCurrentSlice(4);

        const dataLength = this.data.length;
        const sliceWidth = 360 / dataLength;
        const currentAngle = 360 - sliceWidth * (this.currentData - 1);
        const numberOfRotation = 360 * this.countOfRotation;
        const rotation = currentAngle * numberOfRotation;

        this.rotation = Math.round(rotation / sliceWidth) * sliceWidth;

        this.picked = Math.round(dataLength - (this.rotation % 360) / sliceWidth);
        this.picked =
          this.picked >= dataLength ? this.picked % dataLength : this.picked;

        // Center slice
        this.rotation += 90 - Math.round(sliceWidth * 2) + 1;

        const animateArrow = () => {
          return this.arrow
            .transition()
            .duration(this.animDuration)
            .ease(d3.easeLinear)
            .attrTween("transform", this.animArrow)
            .end();
        };

        const animateVis = () => {
          return this.vis
            .transition()
            .duration(this.animDuration)
            .ease(d3.easeLinear)
            .attrTween("transform", this.animRotation)
            .end();
        };

        await Promise.all([animateArrow(), animateVis()]);

        this.arrow.attr("transform", "matrix(1, 0, 0, 1, -95, -350)");

        d3.select(`.slice:nth-child(${this.picked + 1})`).attr("fill", "#ffeb3b");

        this.$emit('done', this.data[this.picked])
      }
    },
    animArrow(to) {
      const matrixPosition = [0, 0.17, 0, -0.17]
      let countAnimationArrow = 0

      return (t) => {
        countAnimationArrow += 1;
        if (countAnimationArrow === 4) {
          countAnimationArrow = 0
        }

        const dynamicMatrixPosition = matrixPosition[countAnimationArrow]

        return `matrix(1, 0, ${dynamicMatrixPosition}, 1, -95, -350)`;
      };
    },
    animRotation(to) {
      const i = d3.interpolate(0, this.rotation - (360 * 5));

      return (t) => {
        return `rotate(${i(t)})`;
      };
    },
  },
});
</script>

<style>
@import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap");

body {
  background: #00bcd4;
}
text {
  color: white;
  font-family: "Roboto";
  font-weight: bold;
  font-size: 1.3rem;
}
circle {
  cursor: pointer;
}
</style>
